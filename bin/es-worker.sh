#!/usr/bin/env bash
#
# es-worker - Generate Cloudflare Worker Code
#
# Scaffolds a new Worker file with correct Env interface based on wrangler.toml.
# Uses "Hard Tools" to parse bindings, then generates boilerplate.
#
# Usage:
#   es-worker api         # Create src/workers/api.ts
#   es-worker webhook     # Create src/workers/webhook.ts
#   es-worker --do MyDO   # Create a Durable Object class
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
GIT_ROOT="$(git rev-parse --show-toplevel)"
OPENCODE_TOOLS="$GIT_ROOT/tool"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Parse arguments
WORKER_NAME=""
DURABLE_OBJECT=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --do)
            DURABLE_OBJECT="$2"
            shift 2
            ;;
        --help)
            echo "Usage: es-worker [WORKER_NAME] [--do DO_CLASS_NAME]"
            echo ""
            echo "Options:"
            echo "  WORKER_NAME    Name for the new worker (creates src/workers/NAME.ts)"
            echo "  --do NAME      Create a Durable Object class"
            echo ""
            echo "Examples:"
            echo "  es-worker api           # Create API worker"
            echo "  es-worker --do Counter  # Create Counter Durable Object"
            exit 0
            ;;
        *)
            WORKER_NAME="$1"
            shift
            ;;
    esac
done

if [[ -z "$WORKER_NAME" ]] && [[ -z "$DURABLE_OBJECT" ]]; then
    log_error "Please specify a worker name or --do for Durable Object"
    echo "Usage: es-worker [NAME] or es-worker --do [CLASS_NAME]"
    exit 1
fi

# Get Env interface from bindings
log_info "Analyzing wrangler.toml bindings..."

if [[ -f "$GIT_ROOT/wrangler.toml" ]]; then
    BINDINGS_OUTPUT=$(node "$OPENCODE_TOOLS/analyze-bindings.js" "$GIT_ROOT/wrangler.toml" 2>/dev/null)
    ENV_INTERFACE=$(echo "$BINDINGS_OUTPUT" | jq -r '.typescript // ""')

    if [[ -z "$ENV_INTERFACE" ]] || [[ "$ENV_INTERFACE" == "null" ]]; then
        log_info "No bindings found, using minimal Env interface"
        ENV_INTERFACE='interface Env {
  // Add your bindings here
  // Example: MY_KV: KVNamespace;
}'
    fi
else
    log_info "No wrangler.toml found, using minimal Env interface"
    ENV_INTERFACE='interface Env {
  // Add your bindings here
  // Example: MY_KV: KVNamespace;
}'
fi

log_success "Env interface generated"

# Create output directory
OUTPUT_DIR="$GIT_ROOT/src/workers"
mkdir -p "$OUTPUT_DIR"

if [[ -n "$DURABLE_OBJECT" ]]; then
    # Generate Durable Object
    OUTPUT_FILE="$OUTPUT_DIR/$DURABLE_OBJECT.ts"

    log_info "Generating Durable Object: $DURABLE_OBJECT"

    cat > "$OUTPUT_FILE" << EOF
/**
 * $DURABLE_OBJECT Durable Object
 *
 * Generated by es-worker
 *
 * Durable Objects provide:
 * - Strong consistency (single-threaded execution)
 * - Persistent state via state.storage
 * - WebSocket support
 * - Alarms for scheduled execution
 */

$ENV_INTERFACE

export class $DURABLE_OBJECT {
  private state: DurableObjectState;
  private env: Env;

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;

    // Initialize state from storage (runs before first request)
    state.blockConcurrencyWhile(async () => {
      // Load initial state
      // this.data = await state.storage.get('data') || defaultValue;
    });
  }

  /**
   * Handle incoming requests
   */
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);

    // Handle WebSocket upgrade
    if (request.headers.get('Upgrade') === 'websocket') {
      return this.handleWebSocket(request);
    }

    // Route by path
    switch (url.pathname) {
      case '/increment':
        return this.handleIncrement();
      case '/get':
        return this.handleGet();
      default:
        return new Response('Not found', { status: 404 });
    }
  }

  /**
   * Example: Atomic increment operation
   */
  private async handleIncrement(): Promise<Response> {
    // Single-threaded - no race conditions!
    const count = await this.state.storage.get<number>('count') || 0;
    await this.state.storage.put('count', count + 1);

    return Response.json({ count: count + 1 });
  }

  /**
   * Example: Get current state
   */
  private async handleGet(): Promise<Response> {
    const count = await this.state.storage.get<number>('count') || 0;
    return Response.json({ count });
  }

  /**
   * WebSocket handling (optional)
   */
  private handleWebSocket(request: Request): Response {
    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);

    this.state.acceptWebSocket(server);

    return new Response(null, { status: 101, webSocket: client });
  }

  /**
   * WebSocket message handler
   */
  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {
    // Handle incoming WebSocket messages
    if (typeof message === 'string') {
      // Broadcast to all connected clients
      this.state.getWebSockets().forEach((socket) => {
        if (socket !== ws && socket.readyState === WebSocket.OPEN) {
          socket.send(message);
        }
      });
    }
  }

  /**
   * WebSocket close handler
   */
  async webSocketClose(ws: WebSocket, code: number, reason: string): Promise<void> {
    // Clean up on disconnect
  }

  /**
   * Alarm handler (optional - for scheduled tasks)
   */
  async alarm(): Promise<void> {
    // Execute scheduled work
    // Reschedule if needed: await this.state.storage.setAlarm(Date.now() + 3600000);
  }
}

/**
 * Don't forget to:
 * 1. Add to wrangler.toml:
 *    [[durable_objects.bindings]]
 *    name = "${DURABLE_OBJECT.toUpperCase()}"
 *    class_name = "$DURABLE_OBJECT"
 *
 * 2. Add migration (first deploy only):
 *    [[migrations]]
 *    tag = "v1"
 *    new_classes = ["$DURABLE_OBJECT"]
 */
EOF

    log_success "Created: $OUTPUT_FILE"

    echo ""
    echo "Next steps:"
    echo "1. Add binding to wrangler.toml:"
    echo ""
    echo "   [[durable_objects.bindings]]"
    echo "   name = \"${DURABLE_OBJECT^^}\""
    echo "   class_name = \"$DURABLE_OBJECT\""
    echo ""

else
    # Generate Worker
    OUTPUT_FILE="$OUTPUT_DIR/$WORKER_NAME.ts"

    log_info "Generating Worker: $WORKER_NAME"

    cat > "$OUTPUT_FILE" << EOF
/**
 * $WORKER_NAME Worker
 *
 * Generated by es-worker
 *
 * Workers are:
 * - Stateless (use KV/R2/D1/DO for state)
 * - Edge-distributed globally
 * - V8-based (Web APIs only, no Node.js)
 */

$ENV_INTERFACE

/**
 * CORS headers for API endpoints
 */
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export default {
  /**
   * Main request handler
   */
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const url = new URL(request.url);

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Route requests
      switch (url.pathname) {
        case '/api/health':
          return Response.json({ status: 'ok' }, { headers: corsHeaders });

        case '/api/example':
          return this.handleExample(request, env);

        default:
          return new Response('Not found', {
            status: 404,
            headers: corsHeaders
          });
      }
    } catch (error) {
      console.error('Worker error:', error);
      return Response.json(
        { error: 'Internal server error' },
        { status: 500, headers: corsHeaders }
      );
    }
  },

  /**
   * Example handler using KV (if configured)
   */
  async handleExample(request: Request, env: Env): Promise<Response> {
    // Example: Read from KV
    // const data = await env.MY_KV.get('key');

    return Response.json(
      { message: 'Hello from $WORKER_NAME!' },
      { headers: corsHeaders }
    );
  },

  /**
   * Scheduled handler (cron triggers)
   */
  async scheduled(
    event: ScheduledEvent,
    env: Env,
    ctx: ExecutionContext
  ): Promise<void> {
    // Handle cron jobs
    // Configure in wrangler.toml:
    // [triggers]
    // crons = ["0 * * * *"]
  },

  /**
   * Queue consumer (if using Queues)
   */
  async queue(
    batch: MessageBatch,
    env: Env,
    ctx: ExecutionContext
  ): Promise<void> {
    // Process queue messages
    for (const message of batch.messages) {
      try {
        // Process message.body
        message.ack();
      } catch (error) {
        message.retry();
      }
    }
  },
};
EOF

    log_success "Created: $OUTPUT_FILE"

    echo ""
    echo "Next steps:"
    echo "1. Update the routes in the fetch handler"
    echo "2. Add any needed bindings to wrangler.toml"
    echo "3. Run: npx wrangler dev"
fi
